<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[header &lt;atomic&gt;]]></title>
    <url>%2F2018%2F08%2F15%2Fatomic%2F</url>
    <content type="text"><![CDATA[std::atomicamomic 类型的obj含有一个T类型的值。atomic obj的主要特性是：当多个不同线程并发访问它包含的值时，不会造成竞态。 代码示例1static std::atomic&lt;int64_t&gt; s_numCreated_;]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[flamingo structure]]></title>
    <url>%2F2018%2F08%2F15%2FflamingoStruct%2F</url>
    <content type="text"><![CDATA[以下是flamingo服务器的全部头文件：timestamp&emsp;&emsp;Done]]></content>
      <categories>
        <category>Server Structure</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++ Trick]]></title>
    <url>%2F2018%2F08%2F15%2FC%2B%2BTrick%2F</url>
    <content type="text"><![CDATA[一个重载用于多个定义多个重载12345678910111213141516171819inline bool operator&lt;(Timestamp lhs, Timestamp rhs)&#123; return lhs.microSecondsSinceEpoch() &lt; rhs.microSecondsSinceEpoch();&#125;inline bool operator&gt;(Timestamp lhs, Timestamp rhs)&#123; return rhs &lt; lhs;&#125;inline bool operator&lt;=(Timestamp lhs, Timestamp rhs)&#123; return !(lhs &gt; rhs);&#125;inline bool operator&gt;=(Timestamp lhs, Timestamp rhs)&#123; return !(lhs &lt; rhs);&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[header &lt;utility&gt;]]></title>
    <url>%2F2018%2F08%2F15%2Futility%2F</url>
    <content type="text"><![CDATA[std::swap交换a和b的值。 代码示例12345678910111213141516171819// swap algorithm example (C++11)#include &lt;iostream&gt; // std::cout#include &lt;utility&gt; // std::swapint main () &#123; int x=10, y=20; // x:10 y:20 std::swap(x,y); // x:20 y:10 int foo[4]; // foo: ? ? ? ? int bar[] = &#123;10,20,30,40&#125;; // foo: ? ? ? ? bar: 10 20 30 40 std::swap(foo,bar); // foo: 10 20 30 40 bar: ? ? ? ? std::cout &lt;&lt; &quot;foo contains:&quot;; for (int i: foo) std::cout &lt;&lt; &apos; &apos; &lt;&lt; i; std::cout &lt;&lt; &apos;\n&apos;; return 0;&#125; std::move返回一个arg的右值引用。 调用std::move就是告诉编译器有一个左值我们想要把它当成右值使用，本质就是向编译器保证：除了重新向该左值（var）赋值或销毁它，不会再去使用它。否则在调用std::move后，若直接访问该左值会产生不确定的数值。 代码示例12345678910111213141516171819// move example#include &lt;utility&gt; // std::move#include &lt;iostream&gt; // std::cout#include &lt;vector&gt; // std::vector#include &lt;string&gt; // std::stringint main () &#123; std::string foo = &quot;foo-string&quot;; std::string bar = &quot;bar-string&quot;; std::vector&lt;std::string&gt; myvector; myvector.push_back (foo); // copies myvector.push_back (std::move(bar)); // moves std::cout &lt;&lt; bar &lt;&lt; std::endl; std::cout &lt;&lt; myvector[1] &lt;&lt; std::endl; return 0;&#125; 左值和右值当把一个obj用作右值时，用的是obj的value（它的内容）。 当把一个obj用作左值时，用的是obj的identity（它的内存地址）。 当右值需要时，可以用左值来替换，但反过来不行。 取址符&amp;会产生右值，其他运算符都产生左值。 左值拥有persist state， 右值是literals或temporary obj。 右值引用这是一个必须与右值绑定的引用。 右值引用通过&amp;&amp;而不是&amp;来获取。 右值引用的重要属性: 它只能与即将要销毁的obj绑定，所以我们可自由地把资源从右值引用‘移动’至另一个obj。 与任何引用一般，右值引用也只是一个obj的别名而已。 我们不能使常规引用（通过&amp;获得的引用，亦称左值引用）去绑定一个需要conversion的表达式，或一个literals，或一个返回左值的表达式。但左值引用刚好相反：它可以绑定上述的任何表达式，但不能直接绑定一个左值。 返回左值引用的函数，以及assignment，subscript，dereference和prefix increment/decrement 运算符，全都返回左值，所以可以将左值引用与任一绑定。 返回值为非引用的函数，以及arithmetic，relational，bitwise和postfix increment/decrement 运算符，全都返回右值，所以可以将右值引用或const左值引用与任一绑定。 因为右值引用只能绑定temporary obj，所以：&emsp;&emsp;被绑定的obj即将销毁&emsp;&emsp;被绑定的obj没有user使用所以可以自由地接管被绑定的obj中的资源 变量（非临时）都是左值。 Reference Collapsing and 左值引用参数有：template void f3(T&amp;&amp;);tip：当一个函数的参数是reference，例如func(int &amp;),则实参传递给函数时实质发生了reference与实参绑定。假设i是一个int型obj，我们会觉得f3(i)是非法的，因为i是左值，而常规来说是不能将右值引用与左值绑定的。但是，有两条额外规定附加于常规中：&emsp;&emsp;1.当传递了实参为左值（e.g.,i）给函数形参为template type param的右值引用（e.g.,T&amp;&amp;），编译器会把template type param推算为实参的左值引用类型，所以，当调用f3(i)，编译器会推算T的类型为int&amp;。这样，f3函数的参数变成f3(int&amp; &amp;&amp;)即对int&amp;的右值引用，常规来说是不能直接定义对引用的引用的，但可以间接地通过type alias或template type param实现。&emsp;&emsp;2.若间接地实现了对引用的引用，则这些引用将“collapse“：引用将collapse to形成一个常规的左值引用，或当且仅当情况为对右值的右值引用时，引用将collapse to形成一个右值引用。归纳起来就是：对于一个给定的类型 X：&emsp;&emsp;&emsp;&emsp;I. X&amp; &amp;, X&amp; &amp;&amp;, 和 X&amp;&amp; &amp; 都会collapse to形成 X&amp;&emsp;&emsp;&emsp;&emsp;II. X&amp;&amp; &amp;&amp; 会collapse to形成 X&amp;&amp; 综上，所以我们可以传任意类型的实参给形参为T&amp;&amp;的模板函数，因为这样的形参明显可以接受右值，又如上述所说，也可以接受左值。]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[header &lt;ctime&gt; (time.h)]]></title>
    <url>%2F2018%2F08%2F14%2Fctime%2F</url>
    <content type="text"><![CDATA[localtime()根据timer指向的代表时间的数值去填结构tm，时间是属于系统所在时区。 形参timer&emsp;&emsp;一个指向含有时间值的obj的指针，time_t是一种类型用来表示时间。 localtime_s()和localtime()有相同效果，但是专用于Windows平台。 123456789101112#include &lt;iostream&gt;#include &lt;time.h&gt;int main()&#123; time_t time_seconds = time(0); struct tm now_time; localtime_s(&amp;now_time,&amp;time_seconds); printf(&quot;%d-%d-%d %d:%d:%d\n&quot;, now_time.tm_year + 1900, now_time.tm_mon + 1, now_time.tm_mday, now_time.tm_hour, now_time.tm_min, now_time.tm_sec);&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[header &lt;type_traits&gt;]]></title>
    <url>%2F2018%2F08%2F13%2Ftype_traits%2F</url>
    <content type="text"><![CDATA[std::common_type 在Types list中获取一个能共同转换成的目标type。这个共同type会被aliased为成员 common_type::type。 模板参数Types&emsp;&emsp;types列表，其中每一个type都是完整的类型或void(可能是cv-qualified类型)。 c-v qualified 类模板生成的类的成员 成员 定义 type Types中所有type都能转化成的 common type 代码示例12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;type_traits&gt;struct Base&#123;&#125;;struct Derived : Base &#123;&#125;;int main() &#123; typedef std::common_type&lt;char,short,int&gt;::type A; // int typedef std::common_type&lt;float,double&gt;::type B; // double typedef std::common_type&lt;Derived,Base&gt;::type C; // Base typedef std::common_type&lt;Derived*,Base*&gt;::type D; // Base* // std::common_type&lt;type1, type2&gt; 使模板类对应的类实例化 typedef std::common_type&lt;const int,volatile int&gt;::type E; // int std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; &quot;typedefs of int:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;A: &quot; &lt;&lt; std::is_same&lt;int,A&gt;::value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;B: &quot; &lt;&lt; std::is_same&lt;int,B&gt;::value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;C: &quot; &lt;&lt; std::is_same&lt;int,C&gt;::value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;D: &quot; &lt;&lt; std::is_same&lt;int,D&gt;::value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;E: &quot; &lt;&lt; std::is_same&lt;int,E&gt;::value &lt;&lt; std::endl; return 0;&#125; std::chrono::common_type(duration) (括号中的duration代表这个模板实例化时要传递的参数类型是duration)这是一个针对std::chrono::duration的std::common_type的specialization. 它根据两个std::chrono::duration定义了一个最精确的std::chrono::duration类型的变量. 它默认返回一个由std::common_type&lt;Rep1,Rep2&gt;为duration第一个模板参数，Period1和Period2的最大公约数为第二个模板参数生成的std:chrono::duration的obj. 类模板实例化后的类的成员 member type 定义 type 最准确的common duration std::chrono::common_type(time_point)这是一个针对std::chrono::time_point的std::common_type的specialization。 它定义了两个std::chrono::time_point的common type,通过利用相同的clock以及两个duration的std::chrono::common_type(duration). 类模板实例化后的类的成员 member type 定义 type time_point的common_type std::remove_reference获取T的非引用type，记得是用类模板实例化后的类的成员‘type’来获取。 类模板实例化后的类的成员 member type 定义 type 若T是引用类型，则type是被引用var的类型，否则type就是T 代码示例1234567891011121314151617181920// remove_reference#include &lt;iostream&gt;#include &lt;type_traits&gt;int main() &#123; typedef int&amp;&amp; rval_int; typedef std::remove_reference&lt;int&gt;::type A; typedef std::remove_reference&lt;int&amp;&gt;::type B; typedef std::remove_reference&lt;int&amp;&amp;&gt;::type C; typedef std::remove_reference&lt;rval_int&gt;::type D; std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; &quot;typedefs of int:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;A: &quot; &lt;&lt; std::is_same&lt;int,A&gt;::value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;B: &quot; &lt;&lt; std::is_same&lt;int,B&gt;::value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;C: &quot; &lt;&lt; std::is_same&lt;int,C&gt;::value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;D: &quot; &lt;&lt; std::is_same&lt;int,D&gt;::value &lt;&lt; std::endl; return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[the usage of 'to which']]></title>
    <url>%2F2018%2F08%2F13%2FEnglish1%2F</url>
    <content type="text"><![CDATA[Obtains the common type for the types in the Types list to which all of them can be converted. || (means equivalent)obtains the commoi type for the types in the Types list which all of them can be converted to.]]></content>
      <categories>
        <category>English Learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[header &lt;chrono&gt;]]></title>
    <url>%2F2018%2F08%2F13%2Fchrono%2F</url>
    <content type="text"><![CDATA[chrono 是一个头文件的名称，也是namespace std 的一个 sub-namespace：所有包含在头文件内的元素都不是直接定义在namespace std中的(其他大部分standard library也是如此)，而是定义在namespace std::chrono内。 在头文件 中的元素用于处理时间。主要通过三个元素：1.Duration它用于测量时间跨度 2.Time points对一个确定时间点的引用 3.Clocks一个框架使一个 time point 与现实物理时间关联起来 chrono中的所有元素 std::chrono::time_point一个 std::chrono::time_point object代表一个相对于clock’s epoch的时间点。tip: epoch 其实是clock的起始时间点 template parametersClock&emsp;&emsp;一个clock class：std::chrono::system_clock, std::chrono::steady_clock, std::chrono::high_resolution_clock,或者自定义的clock。 Duration&emsp;&emsp;std::chrono::duration类型tip:就是相对于clock’s epoch的步进时间值 std::chrono::duration一个 std::chrono::duration object通过一个 count 和一个 period 代表一个时间跨度。 template parametersRep&emsp;&emsp;代表上述的一个count Period&emsp;&emsp;一个std::ratio类型，代表有多少秒tip: 所以 (时间跨度) = (count * std::ratio的obj代表的秒数) std::ratio这个template用来实例化一个type用来表示一个由分子和分母组成的有理数。分子和分母都属于类型 ‘intmat_t’, intmat_t 是范围最大的 signed integer type。 模板参数N分子一个能用 intmat_t 类型表示的绝对值 D分母一个能用 intmax_t 类型表示的绝对值，但不能等于0 Member constants(此模板生成的类的值为常数的成员） member constexpr 描述 num 分子 den 分母 tip: 被声明为constexpr的变量被默认为const，以及必须被constant expressions初始化。 Member types(此模板生成的类的成员变量) member type 定义 描述 type ratio&lt;num,den&gt; 等效的std::ratio类型但有着同时约掉了最大公约数的N:D 模板实例化以下是存在的已预先定义了的std::ratio的标准实例化：&gt;&gt;&gt;&gt;&gt;&gt; std::chrono::system_clocksystem_clock是一个system-wide的realtime clock。realtime&emsp;&emsp;表示真实的时间，能翻译成日历时间或根据日历时间来翻译时间。system-wide&emsp;&emsp;当用这个clcok时，所有进程会获取到相同的std::chrono::time_point 静态成员函数 now 获取当前时间(公共静态成员函数) std::chrono::system_clock::now noexcept一个函数可以被规定为不会抛出异常，加一个 noexcept 关键字在函数的参数列表后即可,如下例子：void recoup(int) noexcept; // 不会抛异常 void alloc(int); // 可能会抛异常 std::chrono::microseconds&gt;是std::chrono::duration的一个实例化，用来表示microseconds，一个或多个一百万分之一秒。 std::chrono::time_point_cast把tp中的duration转变 例子chrono::time_point_castchrono::microseconds(xxx);tip: &lt;&gt;中只提供了 ToDuration 这个模板参数，其他模板参数在xxx中提供即可 std::chrono::time_point::time_since_epoch用来获取1970年1月1日到time_point时间经过的duration。tip: 原来epoch代表的是1970年1月1日 std::chrono::duration::count返回duration obj内部的count。]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[class template and its instantiation]]></title>
    <url>%2F2018%2F08%2F13%2FC%2B%2BTemplate%2F</url>
    <content type="text"><![CDATA[类模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;using namespace std;template&lt; class T &gt;class array // define class template&#123;public: array( int ); T &amp; operator[]( int ); const T &amp; operator[] ( int )const; int getlen() const &#123; return length; &#125; ~array();private: array()&#123;&#125;; int length; T * num;&#125;;template &lt; class T &gt;array&lt; T &gt;::array( int n )// define member function outside class&#123; num = new T[n]; length = n;&#125;template &lt; class T &gt;array&lt; T &gt;::~array()&#123; delete[] num;&#125;template&lt; class T &gt;T &amp; array&lt; T &gt; ::operator[] ( int i )&#123; if( i &lt; 0 || i &gt;= length ) throw string( &quot;out of bounds&quot; ); return num[i];&#125;template&lt; class T &gt;const T &amp; array&lt; T &gt; ::operator[] (int i) const&#123; if( i &lt; 0 || i &gt;= length) throw string( &quot;out of bounds&quot; ); return num[i];&#125;template&lt; class T &gt;ostream &amp; operator&lt;&lt;( ostream &amp; out, const array &lt;T&gt; &amp; A )&#123; for(int i=0; i &lt; A.getlen(); i++) out&lt;&lt; A[i] &lt;&lt; &quot; &quot;; return out;&#125;int main()&#123; array&lt; int &gt; A(10); // the instantiation. for(int i = 0; i &lt; 10; i++) &#123; A[i] = 2*i; &#125; cout&lt;&lt;A&lt;&lt;endl; return 0;&#125; 函数模板123456789101112template&lt;typename T&gt;int compare(const T&amp; left, const T&amp; right) &#123; if (left &lt; right) &#123; return -1; &#125; if (right &lt; left) &#123; return 1; &#125; return 0;&#125;compare&lt;int&gt;(1, 2); //使用模板函数]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++ standard library and namespace]]></title>
    <url>%2F2018%2F08%2F13%2FC%2B%2BStdLibAndNamespace%2F</url>
    <content type="text"><![CDATA[C++ standard libraryC++ standard library 的内容都定义在多个C++的头文件中。由于C++ standard library可能与第三方提供的library存在相同名称的冲突，所以通过namespace来避免这种冲突。 C++ standard library 中所有元素都被定义在namespace std中。没有’.h’后缀的头文件中内容才定义在namespace std中，即调用时需’std::xx..’，而&lt;xxx.h&gt;中的内容并非定义在namespace std中。即调用时无需先写明’std::’。]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hustle but dont know how]]></title>
    <url>%2F2018%2F08%2F13%2Fdiary1%2F</url>
    <content type="text"><![CDATA[Remember there’s lyrics in Eminem’s track:“They dont know what dope is!”hhhh~]]></content>
      <categories>
        <category>not-daily-diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[create category page]]></title>
    <url>%2F2018%2F08%2F13%2Fhexo2%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hot-key to open chrome's book-label]]></title>
    <url>%2F2018%2F08%2F13%2FChrome_hot-key1%2F</url>
    <content type="text"><![CDATA[shift + ctl + o]]></content>
      <categories>
        <category>Chrome&#39;s hot-key</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[markdown usage]]></title>
    <url>%2F2018%2F08%2F13%2Fmarkdown1%2F</url>
    <content type="text"><![CDATA[pic&amp;link separator codeBlock用三个`把代码块包起来即可 123456789string Timestamp::toString() const&#123; char buf[32] = &#123; 0 &#125;; int64_t seconds = microSecondsSinceEpoch_ / kMicroSecondsPerSecond; int64_t microseconds = microSecondsSinceEpoch_ % kMicroSecondsPerSecond; snprintf(buf, sizeof(buf)-1, &quot;%ld.%06ld&quot;, seconds, microseconds); // &apos;-1&apos; is leave a byte for the terminating null byte. return buf;&#125; indenttip: 一般用两个&amp;emsp;作为首行缩进 转义用反斜杠’\’进行转义 常用转义字符 换行 左对齐图片，控制图片style 表格]]></content>
      <categories>
        <category>markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo command]]></title>
    <url>%2F2018%2F08%2F13%2Fhexo1%2F</url>
    <content type="text"><![CDATA[此命令可用于清除categories. 可简写为 ‘hexo s’ 发布博客的command（发布静态网页文件到服务器）:hexo clean &amp;&amp; hexo g &amp;&amp; hexo d]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
</search>
